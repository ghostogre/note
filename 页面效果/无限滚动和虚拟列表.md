**DOM节点过多会造成更多的内存占用**. 例如按照目前的微信小程序限制, 内存占用500M以上会出现卡顿, 甚至闪退.  如果列表中节点没有图片标签, 内存占用现象还不会太明显, 只是DOM节点过多会造成页面渲染耗时增加. 但当列表节点中含有图片时, 内存占用会迅速攀升.

在任何情况下**只对「可见区域」进行渲染**，可以达到极高的初次渲染性能。

我们要实现的无限滚动是指的是，长列表滚动的时候没有分页和加载更多，滚动的时候同时渲染空白的div和请求接口，滚动的时候渲染到空白div里面，滚动过去很多位置的时候回收以前的资源，往回滚动重新加载。

触底加载，然后通过某些方法把新的元素加入到页面末尾。这样的确可以解决分页加载数据的问题，但是在一个数据量比较大的情况下，页面元素会增加得很快，这时就会导致性能问题。

页面上元素太多了，滚动的时候会有卡顿的问题，移动端上更为明显。解决方法就是减少页面元素**。

- 什么时候开始删除元素，什么时候把删了的元素显示回来
- 被删了的元素会导致高度减少，怎样保持总高度不变
- 如何确保列表元素显示在应该出现的位置
- 什么时候开始加载新数据

#### 需求

1. 在滚动的时候渲染空白div，但是还没返回数据，我们不能使用列表的ID，使用index的话假如列表顺序改变或者删除增加，会出现数据和列表无法对应（点击A商品跳到B商品的详情），最大渲染个数我们可以让后台返回total。假如我们在接口没返回数据渲染的话，我们就需要自己给他生成一个ID，例如hash值之类的。
2. TabBar切换的列表，切换的时候要保留滚动的位置，这个时候就需要做资源回收（JD的TabBar列表因为tab极其多，所以没做资源回收），不然的话tab切换太多的时候就会占用过多内存。

#### 解决

1. 虚拟列表

#### 性能测试

1. 使用`window.performance`
2. 使用`console.time`方法与`console.timeEnd`方法

#### 用户体验优化

在图像加载完成时，使用淡入（fade in）效果出现。这在实际情况上会稍微慢一下，应该慢一个过渡执行时间。但用户体验上感觉会更快。这是已经被证实且普遍应用的小“trick”。但是据我感觉，它确实有效。

#### 社区组件

社区实现虚拟列表的React组件很多，较为常用的是`react-virtualized`和`react-tiny-virtual-list`，前一个较为全面，第二个较为轻量。

但是`react-tiny-virtual-list`有一个致命的缺点：*完全不支持子元素的动态高度或者宽度*。

## 实现

1. 使用`padding-bottom`或者一个占位元素，撑起滚动条。
2. 用start，end标志列表的起始终点位置。
3. 在滚动的时候使用`transform: translate(x, y)`修改真实列表的位置。或者修改`padding-top`和`padding-bottom`的值（`padding-bottom`一开始设置高度为列表最大高度减去真实列表高度，假如是动态高度的话，设置成`预估高度 * 列表长度`）
4. 列表项高度固定的情况下，offset直接计算就可以了。
5. 列表项高度不固定的话，需要先获取列表项高度，然后根据scrollTop查找计算到滚动位置对应的index。为了节约计算成本，我们可以用一个`lastIndex`保存上次滚动位置的index，用一个对象保存index列表项对应的offset和列表项的大小。
6. 根据scrollTop计算查找index是顺序查找，我们可以使用二分查找，指数查找等优化查找方法（利用缓存的offset）。

> https://zhuanlan.zhihu.com/p/34585166