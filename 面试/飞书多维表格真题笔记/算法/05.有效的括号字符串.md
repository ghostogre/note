## 有效的括号字符串

给定一个只包含三种字符的字符串：`（` ，`）` 和 `*`，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

- 任何左括号 ( 必须有相应的右括号 )。
- 任何右括号 ) 必须有相应的左括号 ( 。
- 左括号 ( 必须在对应的右括号之前 )。
- `*`可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
- 一个空字符串也被视为有效字符串。

```
输入: "()"
输出: True
示例 2:

输入: "(*)"
输出: True
示例 3:

输入: "(*))"
输出: True
```

### 方法一：暴力法

对于每个 * 号，让我们尝试两种可能性。

**复杂度分析**

**时间复杂度**：O(N * 3^{N})。其中 N 是字符串的长度。对于每个 * 号，我们尝试 3 个不同的值。因此，我们可以检查最多 3^N 字符串的有效性。那么，每一个有效性检查是 O(N)。

**空间复杂度**：O(N)，字符数组使用的空间。

### 方法二：动态规划

如果且仅当间隔 `s[i], s[i+1], ..., s[j]` 能组成有效的括号时，`dp[i][j]`为 true。只有在下列情况下，`dp[i][j]` 才为 true：

- s[i] 是 `'*'` 号, 且在 `s[i+1], s[i+2], ..., s[j]` 这个范围能够组成有效的括号。
- 或者，s[i] 为 `'('`（从左往右，s[i] 不可能是`)`），并且在 `[i+1，j]` 中有一些 k，使得 s[k] 为 `')'`，且 `s[i+1:k]` 和 `s[k+1:j+1]` 截断的两个间隔可以构成有效的括号；

**复杂度分析**

**时间复杂度**：O(N^3)。其中 N 是字符串的长度。有 O(N^2) 时间对应于 dp 的状态，我们对每个状态平均执行 O(N) 工作。

**空间复杂度**：O(N^2)，用于在 dp 中存储中间结果的空间。

```js

```

### 方法三：贪心算法

在检查字符串是否有效时，我们只关心是否 “balance”：当我们分析字符串时计算未配对的左括号的数量。例如，在检查 `“(()())”` 是否有效时，我们在分析字符串时得到了 1, 2, 1, 2, 1, 0 的平衡过程：“(” 有1个左括号，“(” 有2个左括号，“(()” 剩下一个左括号，依此类推。

例如，如果我们有字符串 `(***)`，那么在分析每个符号时，balance 的可能值是 `'('` 对应 [1] ,`'(*'` 对应 [0, 1, 2], `'(**'` 对应 `[0, 1, 2, 3]`, `'(***'` 对应 [0, 1, 2, 3, 4],`'(***)'` 对应 `[0, 1, 2, 3]`。(指的是可能的未匹配的左括号数量)

此外，我们可以证明这些状态总是形成一个连续的区间。因此，我们只需要知道这个区间的左右边界。也就是说，我们将把上面描述的中间状态保持为 `[lo, hi] = [1, 1], [0, 2], [0, 3], [0, 4], [0, 3]`。

**算法**

- 在处理字符串中的当前字符时，让 lo、hi 分别为可能的最小和最大左括号数。

- 如果我们遇到左括号（`c == '('`），那么 `lo++`，若遇到右括号，则 `lo--`。如果我们遇到 * 号且可以转换成左括号（`c != ')'`），则 `hi++`，否则我们转换成右括号，所以 `hi--`。如果 `hi<0` ，那么无论我们选择什么，当前情况都无法生成有效的括号。而且左括号不能小于0。最后，我们应该检查一下是否可以有 0 个左括号。

- lo、hi表示「可能多余的左括号」，一个下界，一个上界，很直观。执行起来就是

  - 遇到左括号：lo++, hi++
  - 遇到星号：lo--, hi++（因为星号有三种情况，如果当做右括号就--，当做左括号就++，也可以当做空字符串）
  - 遇到右括号：lo--, hi--

  lo要保持不小于0。（要理解lo的意思，考虑下这个例子`(**)(`

  如果 hi < 0，说明把星号全变成左括号也不够了，False

  最後，如果 lo > 0，说明末尾有多余的左括号，False

**复杂度分析**

**时间复杂度**：O(N)。其中 N 是字符串的长度,我们对字符串迭代一次。

**空间复杂度**：O(1)，我们使用 lo 和 hi 指针占用常数空间。但是，创建一个新的字符数组需要 O(N) 空间。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var checkValidString = function(s) {
    let lo = 0, hi = 0
    for (str of s) {
        if (str === '(') {
            lo++
            hi++
        } else if (str === ')') {
            if (lo > 0) { lo-- }
            hi--
        } else if (str === '*') {
            if (lo > 0) { lo-- }
            hi++
        }
        if (hi < 0) { // 多余的右括号存在直接就可以退出
            return false
        }
    }
    return lo === 0
};
```

### 方法三

遍历到左括号就入栈， *号的话，需要看栈是否为空，若为空，则记录星数量+1.若不为空，则从栈弹出一个左括号来跟星号合并。并记录合并对数+1； 又括号的话，先看栈是否为空，若为空，则看是否又跟星号合并的左括号。若有，就将其拆开，分出来一个星，星数量+1，记录合并对数-1；若栈不为空，就直接弹栈。 最后，判断栈是否为空即可