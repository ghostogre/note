# 性能优化

1. **合并css文件**，如果页面加载10个css文件，每个文件1k，那么也要比只加载一个100k的css文件慢。 
2. 减少css嵌套，**最好不要嵌套三层以上**。
3. **不要在ID选择器前面进行嵌套**，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。
4. 建立**公共样式类**，把相同样式提取出来作为公共类使用。
5. **减少通配符***或者类似[hidden="true"]这类选择器的使用。
6. 巧妙运用css的继承机制，**如果父节点定义了，子节点就无需定义**。
7. 拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。
8. 不用css表达式。
9. 少用css reset，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。
10. cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。
11. **GZIP压缩**，是一种流行的文件压缩算法。
12. 避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。@import引入css会影响浏览器的并行下载，多个@import会导致下载顺序紊乱。
    - 不要一条条的修改dom的样式，预先定义好class，然后修改dom的classname
    - 不要修改影响范围较大的dom
    - 为动画元素使用绝对定位
    - 不要table布局，因为一个很小的改动会造成整个table重新布局
    - 避免设置大量的style属性，通过设置style属性改变节点样式的话，每一次设置都会触发一次reflow，所以最好使用class属性
    - 如果css里面有计算表达式，每次都会重新计算一遍，触发一次reflow
13. 避免过分重排
14. css动画启用GPU加速，应用GPU的图形性能对浏览器中的一些图形操作交给GPU完成。canvas2D，布局合成，css3转换，css3d变换，webGL，视频
15. 文件压缩能够降低文件大小，但css文件压缩通常只会去除无用的空格，这样就限制来css文件的压缩比例。如果压缩后的文件仍然超过来预期的大小，可以试着找到并删除代码中无用的css。
16. **有选择地使用选择器**（从右向左匹配能够使得css选择器在不匹配的时候效率更高）：
    - 保持简单，不要使用嵌套过多过于复杂的选择器
    - 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。
    - 不要使用类选择器和ID选择器修饰元素标签，如：h3#markdown-content，多此一举，还会降低效率
    - 不要为了追求速度而放弃可读性和可维护性
17. **减少使用昂贵的属性**：在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价，而页面发生重绘时，它们会降低浏览器的渲染性能。

