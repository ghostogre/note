## 主进程和渲染进程

Electron 运行 `package.json` 的 `main` 脚本的进程被称为**主进程**。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。

由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它的叫**渲染进程**的进程中。

在普通的浏览器中，web页面通常在沙盒环境中运行，并且无法访问操作系统的原生资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。

### 区别

主进程使用 `BrowserWindow` 实例创建页面。 每个 `BrowserWindow` 实例都在自己的渲染进程里运行页面。 当一个 `BrowserWindow`实例被销毁后，相应的渲染进程也会被终止。

主进程管理所有的web页面和它们对应的渲染进程。 每个渲染进程都是独立的，它只关心它所运行的 web 页面。

在页面中调用与 GUI 相关的原生 API 是不被允许的，因为在 web 页面里操作原生的 GUI 资源是非常危险的，而且容易造成资源泄露。



1. 渲染线程里的监听页面事件，实际上挂载到了主线程上。所以当刷新或者重启的时候，主进程的监听函数还没有释放，但是上下文已经释放了，就会引发异常。

   例如，我曾经遇到的，我根据书本上的代码在回调里使用了`this.setState`，但是实际上我还没有实现这个`setState`所以会一直报不存在的错误。只会当我实现了`setState`的然后保存，之前挂载到主线程的监听事件依然显示不存在错误，但是`setState`的事件依然能正常执行。其实报错和现在执行的监听事件是两个事件，主线程依然监听之前的函数，现在的函数也被监听了，所以正常的代码能执行，以前的错误也在报错。(即使重新`yarn electron:serve`也是可能还是一样的)

2. 和web应用不一样，web应用启动就是浏览器打开页面，所以不需要频繁重启。但是我们写桌面应用，要从应用打开开始，所以重复启动是正常的。当`background.js`里面点击保存或者修改的时候，就会杀死进程重启而不需要手动重启（技巧）

