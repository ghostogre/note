常用 `setInterval` 来实现前端倒计时

但是存在两个问题：

- 在移动端，浏览器切到后台，页面的定时器就被暂停了。（web端
- 一个页面有多个倒计时，比如商品列表的开售倒计时，当页面打开停留较长时间后，会发现有的商品倒计时会不准确。

最好的解决办法是直接使用`webworker`。

其他办法就是监听`visiblechange`事件来记录定时器暂停那一刻的时间戳，当重新显示的时候根据当前时间重新进行计算。倒计时不准的话，依然可以采用时间戳校准，记录上一次执行的时间戳，和这一次执行的时间戳相减，比较设定的时间间隔，计算出误差时间。

### 使用 setTimeout 而不是  setInterval

用setTimeout模拟定期计时和直接用setInterval是有区别的。

每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）

setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）

### `setInterval()`的问题

使用`setInterval()`的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而JavaScript引擎对这个问题的解决是：当使用`setInterval()`时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。

但是，这样会导致两个问题：

- 某些间隔被跳过；
- 多个定时器的代码执行之间的间隔可能比预期的小

### 定时器的回调函数的this

定时器的回调函数如果不使用箭头函数，那么指向的将会是window对象。