最长公共子串和最长公共子序列的区别为：子串是串的一个连续的部分，子序列则是从不改变序列的顺序，而从序列中去掉任意的元素而获得新的序列；也就是说，子串中字符的位置必须是连续的，子序列则可以不必连续。

### 暴力破解

其实看到这个问题我们直接可以用暴力的方式解决这个问题。给定两个字符串A和B，我们可以通过从A的第一个字符开始与B对应的每一个字符进行对比的方式找到最长的公共字串。如果此时没有找到匹配的字母，则移动到A的第二个字符处，然后从B的第一个字符处进行对比，以此类推。

```javascript
const func = (str1, str2) {
    if (!str1 || !str2) {
        return ''
    }
    const len1 = str1.length, len2 = str2.length
    let maxStr = ''
    for (let i = 0; i < len1; ++i) {
        for (let j = 0; j < len2; ++j) {
            let k = 0, tempStr = ''
            while (i + k < len1 && j + k < len2 && str1[i] === str2[j]) {
                tempStr += str1[i + k]
                ++k
            }
            if (k > maxStr.length) {
                maxStr = tempStr
            }
        }
    }
    return maxStr
}
```

### 动态规划

回顾一下动态规划的解题思路：

1. 从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体的解决方案。
2. 使用一个数组建立一张表，用于存放被分解成众多子问题的解。

**第一步：** 最小的是每个字符，所以要把分解成单个的字符去匹配每个单个的字符。因此这里我们可以得到一张表 `(str1.length + 1) * (str2.length + 1)`。匹配为1，不匹配为0，这个时候我们就分解成为每个字符的匹配情况，由此得到。

**第二步：** 每个子问题有了，这个时候我们要建立一个数组去存放每个子问题的解。关键问题在于，我们怎么样把每个子问题的解存起来，并且可以得到我们想要的结果。对表做一些处理，初始化一个二维数组

```javascript
let arr = new Array(str1.length + 1)
for (let i = 0, len = str1.length + 1; i <= len; ++i) {
    arr[i] = new Array(str2.length + 1)
    for (let j = 0; j <= str2.length + 1; j++) {
        arr[i][j] = 0
    }
}
```

可以看到行和列都多加了一个并且都是0，这是为了判断上一个是否相等的操作，后面你就会明白它的意思了。

需要我们知道起始位置和字符串的长度

```javascript
let maxLen = 0
let index = 0
for (let i = 0, len1 = str1.length; i < len1; ++i) {
    for (let j = 0, len2 = str2.length; j < len2: ++j) {
        if (i === 0 || j === 0) {
            arr[i][j] = 0
        } else {
            if (str1[i] === str2[j] && str1[i - 1] === str2[j - 1]) {
                arr[i][j] = arr[i - 1][j - 1] + 1
            } else {
                arr[i][j] = 0
            }
        }
        if (arr[i][j] > maxLen) {
            maxLen = arr[i][j]
            index = i
        }
    }
}

if (maxLen) {
    return str1.slice(index, maxLen)
}
```



