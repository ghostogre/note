## 题目

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

## 解法

### 动态规划

### 中心扩展算法

观察动态规划可以知道，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。

边界情况即为子串长度为 1 或 2 的情况。枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。

「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。本质为我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。

```ts
function longestPalindrome(str: string): string {
	if (!str) {
    return ''
  }
  let start = 0, end = 0
  for (let i = 0; i < s.length; ++i) {
    const len1 = expandAroundCenter(str, i, i) // 子串长度为1
    const len2 = expandAroundCenter(str, i, i + 1) // 子串长度为2
    const len = Math.max(len1, len2)
    if (len > end - start) {
      // 回文字符串左右对称
      start = i - Math.floor((len - 1) / 2);
      end = i + Math.floor(len / 2);
    }
  }
  return str.substring(start, end + 1)
}

function expandAroundCenter (s: string, left: number, right: number): number {
  while(left >= 0 && right < s.length && s.charAt(left) === s.charAt(right)) {
    --left
    ++right
  }
  return right - left - 1
}
```

时间复杂度：O(n^2)

空间复杂度：O(1)

### Manacher 算法

本算法十分复杂，一般不作为面试内容。专门用于解决“最长回文子串”问题，时间复杂度为 O(N)。

本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，**记录了已经遍历过的子串的信息**，也是典型的以空间换时间思想的体现。

**第 1 步：对原始字符串进行预处理（添加分隔符）**

首先在字符串的首尾、相邻的字符中插入分隔符，例如 "babad" 添加分隔符 "#" 以后得到 "#b#a#b#a#d#"。

1、分隔符是一个字符，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符；

2、**加入了分隔符以后，使得“间隙”有了具体的位置**。**新字符串中的任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应**，因此对新字符串的回文子串的研究就能得到原始字符串的回文子串。

3、新字符串的回文子串的长度一定是奇数；

4、新字符串的回文子串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用。

**第 2 步：计算辅助数组 p**

辅助数组 p 记录了新字符串中以每个字符为中心的回文子串的信息。

手动的计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。

辅助数组 `p` 的最大值就是“最长回文子串”的长度。

**复杂度分析**：

时间复杂度：O(N^2)

空间复杂度：O(N)

不太智能的地方是，对新字符串每一个位置进行中心扩散，会导致原始字符串的每一个字符被访问多次，一个比较极端的情况就是：`#a#a#a#a#a#a#a#a#`。

改进这种算法，使得在填写新的辅助数组 p 的值的时候，能够参考已经填写过的辅助数组 p 的值，使得新字符串每个字符只访问了一次，整体时间复杂度由 O(N^2) 改进到 O(N) 。

具体看 leetcode。