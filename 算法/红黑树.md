从理论上来说，二叉搜索树的查询、插入和删除一个节点的时间复杂度均为O（log(n)）,已经完全可以满足我们的要求了，那么为什么还要有红黑树呢？

我们来看一个例子，向二叉搜索树中依次插入（1，2，3，4，5，6），插入之后就是一条右子树。在这种情况下，二叉搜索树退化成了链表！！！这时候查询、插入和删除一个元素的时候，时间复杂度变成了O（n），显然这是不能接受的。出现这种情况情况的原因是二叉搜索树没有自平衡的机制，所以就有了平衡二叉树的概念。

平衡二叉树保证了在最差的情况下，二叉树依然能够保持绝对的平衡，即左右两个子树的高度差的绝对值不超过1。但是这又会带来一个问题，那就是平衡二叉树的定义过于严格，导致每次插入或者删除一个元素之后，都要去维护二叉树整体的平衡，这样产生额外的代价又太大了。二叉搜索树可能退化成链表，而平衡二叉树维护平衡的代价开销又太大了，那怎么办呢？这就要谈到“中庸之道”的智慧了。说白了就是把平衡的定义适当放宽，不那么严格，这样二叉树既不会退化成链表，维护平衡的开销也可以接受。没错，这就是我们要谈的红黑树了。

**红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须除了满足二叉搜索树的性质外，还要满足下面的性质：**

性质1：每个节点要么是黑色，要么是红色。
性质2：根节点是黑色。
性质3：每个叶子节点（NIL）是黑色。
性质4：每个红色结点的两个子结点一定都是黑色。
性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。

### 红黑树自平衡的实现：

红黑树节点的插入和删除可能会破坏上述红黑树的性质并打破它的平衡，因此需要进行调整从而让红黑树重新恢复平衡；调整分两种方式：旋转以及变色。

```javascript
function RedBlackTree () {
    this.root = null
}
// 创造一个节点
RedBlackTree.prototype.createNode = function (key, redOrBlack) {
    let node = {
    	key,
        left: null,
        right: null,
        parent: null,
        redOrBlack: !!redOrBlack
    }
}

// 插入节点
RedBlackTree.prototype.insertNode = function (newNode, node) {
    if (!this.root) {
        this.root = newNode
    } else if (node.key < newNode.key) {
        if (node.left === null) {
            node.left = newNode
            newNode.parent = node
        } else {
            this.insertNode(node.left, newNode)
        }
    } else {
        if (node.right === null) {
            node.right = newNode
            newNode.parent = node
        } else {
            this.insertNode(node.right, newNode)
        }
    }
}

// 先序遍历
RedBlackTree.prototype.prevSearch = function (node, cb) {
    if (node) {
        cb(node.key)
        this.prevSearch(node.left)
        this.prevSearch(node.right)
    }
}

// 中序遍历
RedBlackTree.prototype.middleSearch = function (node, cb) {
    if (node) {
        this.middleSearch(node.left)
        cb(node.key)
        this.middleSearch(node.right)
    }
}

// 后序遍历
RedBlackTree.prototype.afterSearch = function (node, cb) {
    if (node) {
        this.afterSearch(node.left)
        this.afterSearch(node.right)
        cb(node.key)
    }
}
```

