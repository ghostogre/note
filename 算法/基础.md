## 数字

在处理数字的时候最好检查是否是安全数字（32位系统是`-2^31`到`2^31 - 1`，符号位占一个位置，0算正数，我们一般使用32位作为边界，考虑到32位系统的用户），还可以使用`Number.MAX_VALUE`或者`Number.MAX_SAFE_VALUE`检测边界极限值。假如处理数字之后超出边界了，一般是返回0为结果。

## 字符串

1. **反转整数**：正负数的符号位不影响，所以可以处理非符号位的的翻转，最好再加上符号位。

   - 转换成字符串，然后使用字符串的split转化成数组，然后使用数组的reserve翻转数组，最后使用join转换回字符串。时间复杂度：O(n)，但是因为**整数长度有限**（11位）也可以看做 O(1)。空间复杂度：O(n)
   - 除10取余，从后往前获取数字。时间复杂度：O(n) 或者 O(1)，空间复杂度：O(1)

2. **判断是不是字母异位词（字符串里的字母相同，顺序不同）**：

   - 字符串字母使用split转化成数组，对字符串字母进行排序（sort），然后，比较两字符串是否相等。时间复杂度：O(nlogn)O(nlogn)。空间复杂度：O(n)*O*(*n*)
   - **计数累加**：声明一个对象记录字符串每个字母（汉字也可）的个数，另外一个字符串每项与得到的对象做匹配，最后，根据计数判断是否相等。时间复杂度：O(n)，空间复杂度：O(1)

3. **字符串转换整数**：

   首先，该函数会根据需要丢弃无用的开头空格字符。

   在任何情况下，若函数不能进行有效的转换时，请返回 0。

   假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

   当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

   - **正则匹配**：首先使用正则提取满足条件的字符，`/^(-|\+)?\d+/g`，然后判断目标是否超过 Int 整形最大值或最小值。

     ```js
     const myAtoi = function (str) {
       // 提取需要的字符
       const result = str.trim().match(/^(-|\+)?\d+/g);
       return result
         ? Math.max(Math.min(Number(result[0]), Math.pow(2, 31) - 1), -Math.pow(2, 31))
         : 0; // 使用Math.max和Math.min减少判断嵌套
     };
     ```

     时间复杂度：O(1)，空间复杂度: O(1)

   - **逐个判断**：1. 去除字符串之中的空格。2. 通过执行 `parseInt` 判断是否为数字，不是数字返回 0 （`parseInt`本身就可以把以+，-，数字开头的字符串转化成数字，会丢弃掉后面的数字位，当非数字开头的时候返回NaN）。3. 判断目标是否超过 Int 整形最大值或最小值

     ```js
     /**
      * @param {string} str
      * @return {number}
      */
     const myAtoi = function (str) {
       const news = str.trim();
       if (parseInt(news)) {
         return retrunNum(parseInt(news));
       } else {
         return 0;
       }
     };
     const retrunNum = function (num) {
       if (num >= -Math.pow(2, 31) && num <= Math.pow(2, 31) - 1) {
         return num;
       } else {
         return num > 0 ? Math.pow(2, 31) - 1 : -Math.pow(2, 31);
       }
     };
     ```

     时间复杂度：O(1)，空间复杂度: O(1)

4. **报数**：报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：

   ```
   1.     1
   2.     11
   3.     21
   4.     1211
   5.     111221
   ```

   第 n 项由第 n-1 项推导而来。1 被读作 "one 1" ("一个一") ,  第二项即 11。 11 被读作 "two 1s" ("两个一"）, 第三项即 21。 21 被读作 "one 2", "one 1" （"一个二" , "一个一") , 第四项即 1211。每一项都是依据前一个的读法而来。

   1. **递归**：

      ```js
      const countAndSay = function (n) {
        if (n === 1) {
          return '1';
        }
        const preResult = countAndSay(n - 1); // 获取第 n-1 项的结果。
        /**
          * \d 匹配一个数字
          * \1 匹配前面第一个括号内匹配到的内容
          * (\d)\1* 匹配相邻数字相同的内容
          * 使用replace方法将匹配到的内容处理为长度 + 内容的第一个字符
          * 结果为所求报数
          **/
        return preResult.replace(/(\d)\1*/g, item => `${item.length}${item[0]}`);
      };
      ```

      **复杂度分析**

      - 时间复杂度：O(n)

        本算法涉及递归，代码的调用次数为 nn 次。故而时间复杂度为O(n)。

      - 空间复杂度：O(n)

        递归算法，调用次数随 nn 增加而成线性增加，每次调用申明变量数相同。故而空间复杂度为O(n)。

   2. **迭代**：

      ```js
      const countAndSay = function (n) {
        let result = '1'; // 第一个数为'1'
        for (let i = 1; i < n; i++) { // 循环获取知道第 n 项。
          // 同方法一
          result = result.replace(/(\d)\1*/g, item => `${item.length}${item[0]}`);
        }
        return result;
      };
      ```

      **复杂度分析**

      - 时间复杂度：O(n)
      - 空间复杂度：O(1)

   3. 

