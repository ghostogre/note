## 目标

重构中通积分项目，原项目使用`wepy`开发，在百万数据量的时候会产生大量框架报错，难以debug。项目页面没有细分组件，所有代码集中在一个页面，并且存在大量的if else判断。目标是使用Taro进行重构小程序。

1. 抽出组件，不能与现有业务逻辑耦合。
2. 保证路由不能变，因为上线了的项目有的地址给到第三方了，所以不能改动或者缺少。

## 首页

1. 导航栏滚动渐变：一开始设置背景透明，滚动后从背景透明变成不透明。因为Taro只支持十六进制的颜色，而且只能设置导航栏颜色。所以只能设置`navigationStyle: 'custom'`，自己去实现导航栏，但是兼容性比较差。

2. 下拉加载都是常见的用一个布尔值去防抖。

3. 详情页面复用问题：

   - **问题**：很多页面都复用这个页面，区别只有页面的按钮事件或者局部UI不同。

   - 策略模式：

     ```js
     // 策略类
     const strategies = {
       A() {
         console.log("This is stragegy A");
       },
       B() {
         console.log("This is stragegy B");
       }
     };
     
     // 环境类
     const context = name => {
       return strategies[name]();
     };
     
     // 调用策略A
     context("A");
     // 调用策略B
     context("B");
     ```

   - 解决：

     ```jsx
     // utils/xxx.js[x]
     // 跳转前传给下一个页面
     export const CONSTANT = 'CONSTANT'
     
     // 根据传入判断
     export default {
         [CONSTANT]: () => {
             axios.get()
             return (
             	<>
                 	****
                 </>
             )
         }
     }
     ```

     ```js
     // Map
     const SearchSubmitTypeMap = new Map<SearchSumbitType, { title: string, okText: string }>([
         ['search', { title: '高级查询', okText: '确定' }]
     ])
     ```

     

### 页面组件抽离

1. 一些比较简单的页面结构，样式可以全局复用，而不用抽出组件。抽出组件可以减少模板编写，但是支付宝小程序会有层级性能问题（本项目为微信小程序）
2. 对于一些简单的列表元素其实可以不用组件化，直接列表循环。
10. loginModal降低耦合方法：loginModal仅展示组件，登录操作放到redux里，登录返回信息从缓存或者state里获取。
11. 雪碧图：只有同一页面的切图需要作成雪碧图。

### 难点

1. TabBar的滚动透明:

   ```markdown
   **目标**：滚动之前透明，滚动之后不透明吸顶。
   1. 外层scrollView包裹，通过它的滚动事件获取滚动距离，然后和设定的最大滚动距离（一般小于页面顶部背景图高度）比较运算，然后设置背景透明度。**注：**Taro的入口文件render不能写逻辑，所以我们只能在每个页面引入scrollView
   ```

2. 多个弹窗顺序弹出：每个弹框肯定都是不同的变量控制显示，可以将每个弹框的打开方法（比如说setState）放到一个数组里，然后每次进入下一个弹框就推出数组的第一个。

3. **弹层图片问题**：加载的图片是后台配置的，加载完成后宽高改变（**网络图片事先无法知道高度**），会有一个明显的闪烁。

   - 目标：需要实现图片加载完成后再弹出（类似拼多多的弹出方式），解决其实就是**预加载**。

   - **H5：**可以使用`Image`对象的`onload`预加载。

   - **小程序：**

     - 没有`Image`对象，但是小程序的`Image`组件有onload方法，可以隐藏Image去预加载图片（`display:none`和`visiblity: hidden`其实都会加载图片），只要URL不改变之后都会使用本地的缓存。其实和H5里的Image对象是一样的思路（都是预加载），只不过这里需要一个隐藏的节点代替小程序里没有的Image对象而已。如果好几张图，就用一个数组遍历依次赋值给预加载Image。

       > onload的`e.detail`里面只有宽高，可以通过`e.currentTarget.dataset.src`获取（当然你要在模板上设置`data-src`）

     - 或者`Taro.getImageInfo`(`wx.getImageInfo`)可以去**预加载**图片，在option的success回调里返回值res里的path（图片的本地路径），网络图片需先配置download域名才能生效。

     - 让后台接口直接返回宽高字段，然后使用懒加载就好了。本身后台上传图片，视频之类的媒体的时候，都需要上传宽高字段。这是比较通用的方案。**缺点：**还是会有图片加载的过程，但是简单很多。

     - 给图片加动效，掩耳盗铃的方法。

   - **预加载的思考**：网速慢预加载失败了怎么办，一般来说就是用一个错误的图片代替他，不过说实在的你网速慢获取不到图片不是应该的吗，其他方法也是一样的。

### 注意

1. map循环的时候的return有多个render（比如if else判断返回），会无法通过编译，但是我们可以在return后面使用三元运算符等（例如`return condition ? <A/> : <B/>`）来解决条件渲染的问题。**要求使用一致的 return 语句 (consistent-return)。**

2. 采取bem的类名写法，会出现嵌套比较多的情况。总结出的写法是，外层只留一层容器class包裹，类似滚动view外层还有class的话，可以放到平级这样尽量保证最外层包裹只有一层class，这样可以减少父子class嵌套过多。里面使用&嵌套，一般控制不超过三层，里面再通过类名来控制平级减少sass的嵌套。类似一些里面的状态类可以使用`.className`和`&.className`来嵌套。

   使用&可以减少最终css的嵌套问题，sass的嵌套写法是为了更好的可读性和减少写css的重复。

