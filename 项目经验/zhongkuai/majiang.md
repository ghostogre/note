## 难点

1. 最大参与人数是6人，加上名称列和台板列一共八列。作为微信小程序，用户点击和输入是个问题（输入最好设计成列输入，这其实是设计的问题）。而且移动端最好当然是避免横向滚动了，不然的话容易和手势操作混淆。还有一种方法是自定义输入框吸在键盘上面，但是用户还是会有点击区域过小的问题（`onKeyboardHeightChange`）。

2. 输入的时候需要从回车切换下一个输入框的功能，这样需要我们配置弹起的键盘的按钮文本显示“下一个”，而且还需要注意不要发生频闪。

   > 使用input组件的`bindconfirm`事件，使用input组件的`confirm-type`可以设置按钮文本（设置为next，按钮文本会显示“下一个”）。

3. 输入数字的时候因为可以输入负数（可以欠账），这样的话一般的数字键盘不能使用了（虽然可以使用`.`开头模拟`-`，但是需要给用户注明用`.`代替`-`）。弹出 text 键盘的话，最好能够切换到数字输入（但是社区官方表示无法控制输入法切换到数字）。

   一开始，我的想法是，可以使用一个自定义吸在键盘上面的下拉选择框或者按钮（选择加减）。但是问题在于，这个自定义元素存在于键盘外，点击就会失焦（这时候是点在输入框外了）。

   最终采用`.`代替`-`，但是input输入框（`type='digit'`）在安卓环境下，有时候是不能输入`-`的，键盘输入的`-`会被输入框抛弃。而使用value传入的字符串可以是带`-`的，所以需要我们在失焦的时候把`.`替换成`-`。坑爹的是，假如你再次聚焦，输入框会马上抛弃`-`，也就是会出现聚焦输入框立刻变成正数。

4. 语音播报（同声传译）：可以使用 wx.getRecorderManager 来实现。

5. 同步更新问题：麻将助手只有一个记账人，记账人的记录需要同步到其他人查看的记录里。要求五分钟刷新一次，并且重新进入需要刷新。这需要记账的时候使用长连接每隔一段时间向后台推送一次，然后查看者才能获取更新数据。

6. input**受控组件**：

   **微信小程序**：表单组件不是完全受控的，Input 组件输入后，视图立即变化，但其 value 绑定的值还是旧值，这时你直接 setState 一个旧值会被 Taro 的 diff算法 过滤掉。例如我想要控制去除输入的非数字，当我输入第一个字符是 a 的时候，视图已经更新了，触发的 onInput 事件里我们想要修改 value 为 '' 的时候就会发现没有触发更新。这是因为 value 绑定的值是 '' 而我们更新的值也是 ''，会被diff算法排除。

   所以我们需要在修改之前先把输入的值更新到 value 上去，然后再修改。

   ```ts
   onInput(e) {
     let value = e.detail.value
     // useState 同理
     this.setState({ val: value })
     setTimeout(() => this.setState({ val: value.replace(/[^a-zA-Z]/g, '') }))
   }
   ```

   名称长度限制5个字符：

   ```ts
   let lastIndex = 0
   const len = name.split('').reduce((prev, cur, index) => {
     if (prev <= 5) {
       lastIndex = index
     }
     if (cur.charCodeAt(0) >= 0 && cur.charCodeAt(0) <= 128) {
       return prev + 1
     } else {
       return prev + 2 // 汉字算2个字符
     }
   }, 0)
   ```

   使用 selectionEnd 和 selectionStart 可以设置**聚焦时**输入框内全选（设置从开始到最后一个字符）

7. 微信小程序数字键盘和普通键盘高度是不一样的，实现下一项功能的时候需要区别数字键盘弹起或者普通键盘弹起。

8. **页面隐藏（切换APP）**的时候，键盘会收起，但是没有触发失焦事件。例如使用了键盘吸顶的按钮，切换页面之后可能会出现吸顶按钮依然停留的问题，需要在页面切换的时候及时处理。同样的，使用focus属性指定输入框的焦点的时候，即使点击输入框外如果focus的值不变是**不会失焦**的。

9. 微信限制`getUserInfo`不能在进入的时候就获取，进入的时候获取大概率是失败的。需要用户主动点击授权的时候获取，然后保存到后台（所以没法即使更新）

10. 麻将小程序有个**自动计算**功能，当第四个输入的时候会自动计算出第四个牌友的筹码，可以使用 JS 的 Map 进行实现，牌友序号 index 对应牌友的筹码，通过 size 可以获取到里面的键值对（清空可以使用 delete 删除，删除后 size 也会改变，相对于对象键值对好处就是可以获取长度，删除操作更加方便）。 每次输入完成，失焦的时候，将筹码填入Map，聚焦最后一个牌友的时候自动计算（使用 forEach 和 for...of 即可遍历）。使用 clear 方法即可清空 map 十分方便。而且为了保证数据同步更新，**计算和判断的时候最好使用 useRef 里 map 数据进行判断**。

    自动计算出了很多bug，反思一下，写代码前各种自动计算的情况需要我们一条条理清楚，否则如果修改多次迭代后代码可能积重难返变成屎山。

    区分触发自动计算的情况：

    - 有台板的情况，并且台板未输入，第四个牌友输入完成后，自动计算台板。
    - 有台板的情形，先输入台板，第三个牌友输入完成后，自动计算第四个牌友。
    - 无台板的情况，第三个牌友输入完成后，自动计算第四个牌友。
    - 前三条都是输入完成后自动计算，这种情况只能在4个牌友的时候，如果超过4个人，需要在第四个人的筹码输入框聚焦的时候触发自动计算。

11. 在后续开发过程中出现了许多bug，与支付宝小程序不同，可以使用真机调试控制台打印一步一步调试bug，对于每个判断条件里循环打印。

12. **输入框失焦和按钮点击事件的顺序**：是先点击事件触发，然后才有的输入框失焦（IOS）。如果点击的时候需要用到输入框的数据，那么需要保证点击的时候数据就更新了，最好是在input事件的时候进行同步更新。（iOS会遇到这种情况，但是Android不会遇到这样的情况）

13. 每个函数只做一件事，这样的话修改需求或者增加需求的时候就可以防止代码过度混乱。逻辑理不清楚主要就是一个函数做太多事情了，比如聚焦自动计算和失焦自动计算可以分两个函数从 focus 事件和 blur 事件里分别抽出。比如当遇到需要遍历数组找到对应index的逻辑代码可能在其他出现也可以抽出一个单独的函数。再比如`inputChipMap.current.set`这样的长串代码可以用一个函数替换成更短的写法，而且我们需要在输入字符串不是空字符串的时候添加到 map，输入字符串为空字符串的时候从 map 里删除，这样的判断正好也可以正好一起放到一个函数里。

