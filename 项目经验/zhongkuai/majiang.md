## 难点

1. 最大参与人数是6人，加上名称列和台板列一共八列。作为微信小程序，用户点击和输入是个问题（输入最好设计成列输入，这其实是设计的问题）。而且移动端最好当然是避免横向滚动了，不然的话容易和手势操作混淆。还有一种方法是自定义输入框吸在键盘上面，但是用户还是会有点击区域过小的问题（`onKeyboardHeightChange`）。

2. 输入的时候需要从回车切换下一个输入框的功能，这样需要我们配置弹起的键盘的按钮文本显示“下一个”，而且还需要注意不要发生频闪。

   > 使用input组件的`bindconfirm`事件，使用input组件的`confirm-type`可以设置按钮文本（设置为next，按钮文本会显示“下一个”）。

3. 输入数字的时候因为可以输入负数（可以欠账），这样的话一般的数字键盘不能使用了（虽然可以使用`.`开头模拟`-`，但是需要给用户注明用`.`代替`-`）。弹出 text 键盘的话，最好能够切换到数字输入（但是社区官方表示无法控制输入法切换到数字）。

   一开始，我的想法是，可以使用一个自定义吸在键盘上面的下拉选择框或者按钮（选择加减）。但是问题在于，这个自定义元素存在于键盘外，点击就会失焦（这时候是点在输入框外了）。

   最终采用`.`代替`-`，但是input输入框（`type='digit'`）在安卓环境下，有时候是不能输入`-`的，键盘输入的`-`会被输入框抛弃。而使用value传入的字符串可以是带`-`的，所以需要我们在失焦的时候把`.`替换成`-`。坑爹的是，假如你再次聚焦，输入框会马上抛弃`-`，也就是会出现聚焦输入框立刻变成正数。

4. 语音播报（同声传译）：可以使用 wx.getRecorderManager 来实现。

5. 同步更新问题：麻将助手只有一个记账人，记账人的记录需要同步到其他人查看的记录里。要求五分钟刷新一次，并且重新进入需要刷新。这需要记账的时候使用长连接每隔一段时间向后台推送一次，然后查看者才能获取更新数据。

6. input**受控组件**：

   **微信小程序**：表单组件不是完全受控的，Input 组件输入后，视图立即变化，但其 value 绑定的值还是旧值，这时你直接 setState 一个旧值会被 Taro 的 diff算法 过滤掉。例如我想要控制去除输入的非数字，当我输入第一个字符是 a 的时候，视图已经更新了，触发的 onInput 事件里我们想要修改 value 为 '' 的时候就会发现没有触发更新。这是因为 value 绑定的值是 '' 而我们更新的值也是 ''，会被diff算法排除。

   所以我们需要在修改之前先把输入的值更新到 value 上去，然后再修改。

   ```ts
   onInput(e) {
     let value = e.detail.value
     // useState 同理
     this.setState({ val: value })
     /** 记得要清理定时器!!!!!! */
     const timer = setTimeout(() => {
       clearTimout(timer)
       this.setState({ val: value.replace(/[^a-zA-Z]/g, '') })
     })
   }
   ```

   > 上述写法需要及时**清理定时器**，安卓大内存可能没问题，但是更加严格的IOS会出现卡死无反应的情况。

   名称长度限制5个字符：

   ```ts
   let lastIndex = 0
   const len = name.split('').reduce((prev, cur, index) => {
     if (prev <= 5) {
       lastIndex = index
     }
     if (cur.charCodeAt(0) >= 0 && cur.charCodeAt(0) <= 128) {
       return prev + 1
     } else {
       return prev + 2 // 汉字算2个字符
     }
   }, 0)
   ```

   使用 selectionEnd 和 selectionStart 可以设置**聚焦时**输入框内全选（设置从开始到最后一个字符）

7. 微信小程序数字键盘和普通键盘高度是不一样的，实现下一项功能的时候需要区别数字键盘弹起或者普通键盘弹起。

8. **页面隐藏（切换APP）**的时候，键盘会收起，但是没有触发失焦事件。例如使用了键盘吸顶的按钮，切换页面之后可能会出现吸顶按钮依然停留的问题，需要在页面切换的时候及时处理。同样的，使用focus属性指定输入框的焦点的时候，即使点击输入框外如果focus的值不变是**不会失焦**的。

9. 微信限制`getUserInfo`不能在进入的时候就获取，进入的时候获取大概率是失败的。需要用户主动点击授权的时候获取，然后保存到后台（所以没法即使更新）

10. 麻将小程序有个**自动计算**功能，当第四个输入的时候会自动计算出第四个牌友的筹码，可以使用 JS 的 Map 进行实现，牌友序号 index 对应牌友的筹码，通过 size 可以获取到里面的键值对（清空可以使用 delete 删除，删除后 size 也会改变，相对于对象键值对好处就是可以获取长度，删除操作更加方便）。 每次输入完成，失焦的时候，将筹码填入Map，聚焦最后一个牌友的时候自动计算（使用 forEach 和 for...of 即可遍历）。使用 clear 方法即可清空 map 十分方便。而且为了保证数据同步更新，**计算和判断的时候最好使用 useRef 里 map 数据进行判断**。

    自动计算出了很多bug，反思一下，写代码前各种自动计算的情况需要我们一条条理清楚，否则如果修改多次迭代后代码可能积重难返变成屎山。

    区分触发自动计算的情况：

    - 有台板的情况，并且台板未输入，第四个牌友输入完成后，自动计算台板。
    - 有台板的情形，先输入台板，第三个牌友输入完成后，自动计算第四个牌友。
    - 无台板的情况，第三个牌友输入完成后，自动计算第四个牌友。
    - 前三条都是输入完成后自动计算，这种情况只能在4个牌友的时候，如果超过4个人，需要在第四个人的筹码输入框聚焦的时候触发自动计算。

11. 在后续开发过程中出现了许多bug，与支付宝小程序不同，可以使用真机调试控制台打印一步一步调试bug，对于每个判断条件里循环打印。

12. **输入框失焦和按钮点击事件的顺序**：是先点击事件触发，然后才有的输入框失焦（IOS）。如果点击的时候需要用到输入框的数据，那么需要保证点击的时候数据就更新了，最好是在input事件的时候进行同步更新。（iOS会遇到这种情况，但是Android不会遇到这样的情况）

13. 每个函数只做一件事，这样的话修改需求或者增加需求的时候就可以防止代码过度混乱。逻辑理不清楚主要就是一个函数做太多事情了，比如聚焦自动计算和失焦自动计算可以分两个函数从 focus 事件和 blur 事件里分别抽出。比如当遇到需要遍历数组找到对应index的逻辑代码可能在其他出现也可以抽出一个单独的函数。再比如`inputChipMap.current.set`这样的长串代码可以用一个函数替换成更短的写法，而且我们需要在输入字符串不是空字符串的时候添加到 map，输入字符串为空字符串的时候从 map 里删除，这样的判断正好也可以正好一起放到一个函数里。

14. **点击计算按钮后输入框不会清空**：只有四个牌友时，当我输入完成第三个牌友然后直接点击计数，要求是直接算出第四个牌友（自动计算）。但是就经常会出现第三个牌友输入框计数后没有清除的情况（每次计数后，应该对每个牌友的金额进行清空操作），原因是输入前，输入框value是空字符串，输入后先触发点击然后失焦，最后又要清空这个输入框，有可能失焦和输入框操作state两次合并了。也就是说最终就是一次设置输入框值为空字符串，但是虽然输入框里有输入，但是react绑定的value还是空字符串，也就会被react优化掉不执行，自然没有清空。处理方法是，清空操作放到`setTimeout`里，然后再清空操作前执行一次设置牌友的筹码为0的遍历。

15. 03/11 出现了输入的时候会突然增加牌友数，但是在输入相关的方法里都没有增加牌友操作，只有在设置牌友数的时候有牌友操作。思考了一下只可能是key值导致的react重复渲染，使用的是`player` + `chip`（牌友名称加上筹码数）作为 key ，仔细思考了一下假如同名同筹码就会出问题的（本身这是为了防止使用playerId导致复用出现显示问题 - 牌友的playerId都是固定的从1到最多6），解决方法是使用`JSON.stringfy`序列化整个牌友对象作为key或者使用gameId + playerId，这样的话重复几率基本没有了。

16. getStorage 在支付宝上无论本地有没有记录都会返回成功（response为空），而微信上没有key对应的值就是报错。

17. 结构类似的节点会被 diff 算法复用，所以切换显示内容的时候偶尔会出现内容切换显示不正确，可以**使用 key 来重新渲染内容**。

18. 查看者新开桌后（编辑页面），微信小程序切到后台一段时间后，再次进入依然是查看者页面（IOS端）。

    解决办法，直接使用场景值判断，场景值为1047的时候为扫码进入，这时候才去加载查看者。

    使用`Taro.getLaunchOptionsSync`(`wx.getLaunchOptionsSync`)才能获取到 scene 场景值。

    useRouter` 是 Taro 专有的 Hook，等同于页面为类时的` `getCurrentInstance().router` （path, params都从这里获取到，但是scene总是undefined）

    #### 小程序启动
    小程序启动可以分为两种情况，一种是冷启动，一种是热启动。

    **冷启动** ：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
    冷启动会调用onLoad()。冷启动就是重新加载小程序，根据小程序pages数组设置的页面展示第一个。

    **热启动** ：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。根据进入方式会有个别影响的，大部分还是会保留之前的页面的。

    `onShow()`不管冷启动还是热启动都会调用。

    #### 运行机制

    ##### 小程序没有重启的概念

    当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁
    当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁。

    #### 前台/后台状态

    小程序启动后，界面被展示给用户，此时小程序处于前台状态。

    当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有完全终止运行，而是进入了后台状态，小程序还可以运行一小段时间。

    当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台状态。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被销毁，即完全终止运行。

    

