## 细节

1. 项目使用 dva 内置的`redux` + `redux-saga`。 在`app.tsx`直接导入store，就可以直接使用dvaApp的redux，以后`useSelector`和`useDispatch`。Taro默认会给你生成store目录，里面使用`redux`和`redux-thunk`

   ```jsx
   // dva.ts
   import Taro from '@tarojs/taro'
   import { create } from 'dva-core';
   import { useSelector, useDispatch } from '@tarojs/redux';
   import { createLogger } from 'redux-logger';
   // import createLoading from 'dva-loading';
   import immer from 'dva-immer';
   let app
   let store
   let dispatch
   let registered
   
   function createApp(opt) {
     // redux日志
     // opt.onAction = [createLogger()]
     app = create(opt)
     app.use(immer())
   
     // 防止重复注册
     if (!registered) opt.models.forEach(model => app.model(model))
     registered = true
     app.start()
   
     store = app._store
     app.getStore = () => store
     app.use({
       onError(err) {
         if(err.code!=212){
           Taro.showToast({
             title: err.message
           })
         }else{
           Taro.removeStorageSync('token')
           dispatch({type:'common/save', payload: {
             isLogin: false,
           }})
         }
         console.log(err);
       },
     })
   
     dispatch = store.dispatch
   
     app.dispatch = dispatch
     return app
   }
   
   export default {
     createApp,
     getDispatch() {
       return app.dispatch
     }
   }
   
   // app.tsx
   const dvaApp = dva.createApp({
     initialState: {},
     models: models,
   });
   
   const store = dvaApp.getStore();
   
   // render
   <Provider store={store}></Provider>
   ```

2. `git remote update origin --prune`  找不到新创建远程分支的时候使用，可能远程新创建了分支，但是本地的源没更新。

5. Taro一个函数只能有一个渲染函数。

6. `npm config get prefix`：查看全局包安装路径。

7. 命令行脚手架一般安装在 `C:\Program Files\nodejs` 下面的node_modules。

8. `git pull origin master`：在适当的时候，每一个个人分支都需要 `pull` 一下 `master` 分支，以保证自己本地的代码的版本不会低于服务器。

9. page的文件夹要用小写字母开头否则开发工具找不到。

10. eslint：`Absolute imports should come before relative imports`，绝对引入应该在相对地址引入的前面。

11. 不要在支付宝小程序里使用`PickerView`和`PickerViewColumn`的时候动态渲染，会报错而无法渲染，错误的引用微信小程序的组件。（其中只可放置 picker-view-column 组件，其它节点不会显示）

12. 在eslint里要使用`Number.isNaN`判断是不是NaN，而不是直接全局`isNaN`。

13. 使用Number可以将`''`转换成数字0，使用parseInt和直接乘以1会出现NaN的情况（undefined和非数字字符串）。

14. 支付宝的地图，文档上说是原生组件永远位于最高层级。但是实际上使用还是可以在上面显示其他东西的。支付宝的地图开发的时候，需要包裹一个父元素，高度依赖于父元素（flex布局实测无效，最好给父元素指定明确的高度，calc计算的高度也是可以的）。

15. **滚动穿透**：该项目里我采用的方法是设置页面刚好占满一屏，然后每次打开弹窗的时候，设置地图不可滚动。

14. 自定义hook不能顶层调用。

    ![img](./images/coupon.png)

    css实现思路参考：https://www.jianshu.com/p/3c652606e6d6

15. https://opendocs.alipay.com/mini/framework/performance-tips性能优化建议，官方建议减少层级嵌套和过多的节点。

16. CSS最好还是用BEM的方法，保证类名不冲突，因为用外层类限制也会出现其他同名类影响到样式的情况。

17. 一些需要权限的页面，我们可以根据登录情况放一层透明全屏的遮罩层，点击触发登录。

18. 支付宝静默授权接口`my.getAuthCode`有一定几率调用失败，需要处理在调用失败的时候重新获得授权。最好是在相关操作接口上触发用户未授权，然后catch错误里重新获取授权。或者说用一个变量控制次数，失败后调用重新获取授权。

19. 红包倒计时一个页面里，例如页面上方的倒计时和吸顶倒计时不一样的话，可以在页面里计算倒计时，将时分秒等传入到组件里去。

## 踩坑

1. tarojs/cli偶尔会出现编译问题，明明在我的代码里props传值了，但是到编译后的代码就会出现props传值为undefined，而且时有时无。这种时候就需要我们**重新触发编译**。

2. 图片名称中不能存在空格，阿里云虽然支持转义空格，但是在小程序里还是会出现问题。

3. **taro脚手架的坑**：在win10中，2.2.4以及之前的版本，运行的时候会出现找不到`config/index`目录的问题。虽然说，官网说脚手架尽量与项目中保持一致，但是其实2.2.6脚手架运行2.2.4的项目是没问题的。

4. **开发工具的坑**：在开启支付宝小程序开发工具的时候，假如编译报错修复后会一直无法编译（即使反复确认没有错误），可能需要关闭开发工具，然后重新`yarn dev:alipay`。开发工具偶尔会出现请求不发送的情况，只能重启开发工具。

5. `CoverView`在支付宝小程序中无法点击。

6. `hideLoading`和 `showToast`，之前原生微信小程序开发的时候，`hideLoading`必须先在`showToast`前执行，不然toast也会被隐藏。但是Taro编译的支付宝小程序有的时候就会出现toast无法渲染出来的情况，所以最好给`hideLoading`使用`setTimeout`处理。

7. 红包金额需要考虑到5个半字体的大小，小数点后两位，小数点占半个字体的大小。

8. intersectionobserver 开发工具不可用，但是可以直接在真机里使用。

9. **支付宝小程序不能设置key**，假如页面会排序（例如红包商品列表，点击后有已领取的状态的会排在前面）就会出现排序后，点击跳转错位的情况。

10. `onClose && onClose()`这种函数判断是否存在并执行的写法，有时候会发生编译出错。

    ```js
    onClose && onClose()
    // taro编译后变成
    on;
    Close && _this2.props.onClose();
    // 解决方法：注释掉这句代码，编译一次，然后再次打开这句代码就会正常的编译
    // 正常编译
    onClose && _this2.props.onClose();
    ```

11. 不要给page设置CSS，会影响到其他页面的显示样式，除非是通用样式。

12. `useReachBottom`等页面钩子在自定义组件里不会触发。

13. 解构赋值的时候，如果key值对应的value是null，是不会赋默认值的。（例如`const { key = 1 } = { key: null }`，最后key的值是null）,所以不可以使用解构赋值的默认值来解决判断后台API返回是不是null的问题。

14. `encodeURI`不会转义特殊字符，如果拼接的URL比较多，可能会被特殊符号截断，比如有&符号的话会被当成参数截断，导致URL不完整。这个时候可以使用`encodeURIComponent`处理。

15. 切换tab的时候，可能会出现tab的下划线动画卡顿，这是因为同时进行请求接口数据渲染，所以需要延时到动画完成再去进行接口数据请求。而且切换的时候需要显示列表为加载中状态，否则切换的时候会有其他tab的列表。

16. uma一直存在bug，一直报错`TypeError: null is not an object (evaluating 'o.header')`。debug的时候代码是混淆压缩后的build代码，dev的时候`build --watch`的js是没有压缩和混淆过的，最好对照着非混淆的找，就能找到是哪个包的问题。

17. **Bug**：支付宝的api 使用`getLocation.object.type`设置经纬度类型的时候，必须使用数字指定type而不是字符串数字（否则会一直无效）。

18. 支付宝报错："用户不存在，权限不正确"。可能是静默授权失败没获取到token，问题可能在于：1 - 静默授权API调用失败，2 - 调用静默授权接口在需要的列表接口之后返回（可以尝试刷新后验证），3 - 静默授权获得的`auth_code`在后台接口没有找到对应的token和userid。

19. taro 2.0+版本编译小程序，打包存在问题，本地打包完能够正常运行。但是上传后会报系统错误，原因是npm和yarn安装路径不同。修改配置文件，使用npm全局安装脚手架，然后删除`node_modules`重新运行`npm i`，再打包就可以正常运行了。

## 平台差异

1. 透明渐变导航栏：支付宝小程序自己支持，在config里设置`"transparentTitle": "auto"`。
2. 带有扩展组件库，包含UI组件和营销组件。
3. API以`my.`开头。Taro 项目 支持 Taro 的代码与小程序（微信/百度/支付宝/字节跳动）原生的页面、组件代码混合存在
4. `Taro.getOpenUserInfo()`：此接口可获取支付宝会员的基础信息。如需获取支付宝会员标识（user_id），请调用 `my.getAuthCode `和 `alipay.system.oauth.token` 接口。
5. 支付宝diff算法有问题所以不能使用key，否则假如列表顺序变化，会出现点击A跳转到B的情况。

## 我的贡献

1. 贡献业务代码。
2. 重构项目时，推动项目组使用duck扁平化数据。
3. 使用key-value方法代替if else判断，抽离代码集中管理（utils），提升了代码可复用性。
4. 优化代码中大量混乱的数据，集中到js文件中过管理。

## 难点

1. 首页翻牌抽奖，要在点击翻牌后才从后台获取抽奖结果，之后在获取奖品列表的形式。但是翻牌的顺序和奖品列表顺序是不同的？这要如何才能既要保证不重复，也要保证抽奖结果的位置不变。**我的思路：**记录抽奖结果的index，将抽奖结果id和抽奖列表数组进行对比，然后交换列表中结果index对应的奖品和抽奖结果。

2. redux中保存`statusBarHeight`和`titleBarHeight`，考虑到获取的statusBar高度和titleBar高度可能有问题，所以做好每次展示都获取一次（这种情况就不需要本地缓存了）

3. **背景图问题：**优惠券这类背景存在不透明的小缺口，而且容器本身还有图片背景，还得考虑到小程序兼容性问题。

   - **方案一**：考虑直接使用整张背景图，类似背景图上的大字也可以切到一张图上。但是这样的话类似优惠券有不同状态可能就需要我们自己判断一下再显示。背景图的话文字可能会比图先渲染，最好的方法是使用图片onload方法，使用一个变量控制img的display（`display:none`依然会加载图片），加载完成后再显示。（中间可以使用fadein等动效增加用户体验）
   - **方案二**：类似方案一，直接对整个优惠券使用淡入淡出动效，减少图片加载的闪烁的影响。
   - **方案三**：直接把圆形缺口的容器背景图切出来，作为伪元素，这样就看上去和透明的一样了。然后背景直接可以使用CSS实现，小圆缺口的图比较小也不会有加载问题。**缺点**就是要保证和容器背景图不会出现错位，而且优惠券列表的话，不同位置需要切多个不同的小圆切口的图。。。所以这个方法只适合比较少的列表或者纯色背景。
   - **方案四**：使用CSS的渐变来实现透明的小圆点到白色背景的效果，但是兼容性担忧。

4. 每日签到：连续七天有礼包，签到天数分两行显示。因为实际显示的是两行七天，第七天奖励不是在第三个的位置就是在第七个位置。我们可以减去那些成功连续七天签到的天数，剩余天数必定小于7。然后讨论剩余天数大于4还是小于4的情况，剩余天数等于0特殊情况单独讨论。

5. 原本红包页面是红包信息和红包有效期倒计时，以及红包商品列表。现在首页和快递券页面，底部也要添加红包倒计时和红包商品列表。红包商品列表的样式没有大的改变，所以可以分别抽出成列表和列表项组件。但是商品领券（点击列表项即领券）的时候，还需要验证红包余额和红包与有效时间，这样的话就需要把红包有效期和红包余额作为props，列表的领券流程和逻辑放到列表组件里。红包倒计时以及余额的显示样式在首页，快递页面都不同，所以红包信息放到页面里处理，列表组件只处理下单相关的逻辑（虽然还是要传入红包有效期等字段）。

   红包信息模块和吸顶红包信息分成两个组件，因为需要监听红包信息滚出可视范围再显示吸顶，所以吸顶应该是红包信息组件的子组件。

   列表请求和红包信息请求要放到页面中，因为页面钩子不会在组件里生效。

6. 静默登录：有的时候即使用户没有完全登录（手机等验证），有的页面还是能够让用户进行操作，直到一些需要手机验证绑定的页面我们再进行完全的登录。

7. **新加入的接口要新增到URL配置文件**，不能直接修改原来的配置文件，可能会存在其他页面也使用该接口的情况。

8. 渲染的顺序和拿到数据的顺序有关，想要优先显示内容可以把次要内容放到then里面。

9. 获取接口返回数据含`\n`，但实际展示时却不能换行，而是展示成字符串`\n`。网上的答案是说，后台接口会给他转换成`\\n`，确实后台接口会转换成`\\n`，但是在支付宝小程序开发工具里接口返回的json里确实是`\n`，可是依然不会换行，但是如果使用`str.replace('\\n', '\n')`却能换行了（`\`表示转义）。我理解是，`\\n`被转义了所以虽然显示是`\n`但是是字符串`\n`，而不是换行符了。

10. **小程序毫秒级倒计时**（类似`24:00:21:9`这样的倒计时，最后一位是100毫秒这样）：毫秒级倒计时问题在于会导致页面非常卡顿，经常出现例如在`00:00:10:8`停顿一下，然后就变成了`00:00:09: 9`然后继续快速的倒计时。这时候我们可以使用`window.requestAnimationFrame`模拟定时器，可以减少很多卡顿问题。

    >**其他解决方法：**
    >
    >1. 直接在毫秒位放一个GIF，不要求细度，反正毫秒级的倒计时用户看不清而且也不会去关注。毫秒级倒计时主要是为了增加用户紧迫感。

    

11. **列表组件代码复用**：类似红包页面的列表组件，因为需要在很多页面用到，所以下单还有一些弹框什么的都封装到了列表组件里面，列表元素组件单独再抽成一个展示组件这样的两层结构。每个页面的红包列表样式都是一样，所以没有什么问题，但是现在新需求来了：一个新的页面也包含这个红包列表，但是红包列表元素的tag栏显示不一样。这样的话虽然我们可以把tag栏抽成组件，但是这么传入比较好呢？直接从列表组件传props再传到列表元素的组件props上，耦合太高了，完全没有组件的灵活性可言。

    最好的方法是：将一个 render 函数（返回JSX对象的函数）作为 list 组件的 props 传入，在 listItem 的 render props上调用这个函数（将商品对象作为传参传入函数中），或者说直接给list传入一个render函数，里面自定义渲染 listItem 。类似antd的tree组件的自定义渲染就是props传递一个render函数。

    考虑过使用**高阶组件**，但是高阶组件用途不同，主要是传入有个组件返回一个新的组件，高阶组件用来操作props，组件提升状态，包裹组件，使用ref操作组件等。在此使用并不合适。

    最近还是要重做列表组件，因为购物补贴的逻辑和接口不同，可以复用的只有列表商品组件。

12. **支付宝跳转卡券页面：**从小程序跳转到支付宝领券组件，领券组件在用户操作后会退出，可监听页面切回前台事件进行后续处理（刷新、跳转其他页面）。切回前台和切到后台和支付宝APP切换前后台是一致的（支付宝切换前后台，小程序不会关闭的），所以最好用一个单独的中转页进行处理。

13. 数字滚动效果（transform）：

    - `isNaN`可以判断是否是数字或者是否可以被转换成数字。例如`isNaN(' ')`结果是false，`isNaN(',')`的结果是true。
    - `CSS`属性：`writing-mode`，可以用它使文本垂直排列而不需要写多个换行或者块元素换行：
      - `horizontal-tb`：默认值，表示水平排版，从上到下。
      - `vertical-lr`：表示垂直排版，从左到右。
      - `vertical-rl`：表示垂直排版，从右到左。
      - 注意：垂直排版的时候，`line-height`设置的是横向的宽度。
    - 垂直滚动然后设置每个数字滚动元素高度为`fontSize * 10`，然后使用`transform`来设置滚定距离。
    - 在iOS里垂直排版可能存在问题，所以放弃使用`writing-mode`实现垂直排版。
    
14. **Flex 布局会默认：**

    - 把所有子项变成水平排列。
    - 默认不自动换行。
    - 让子项与其内容等宽，并把所有子项的高度变为**最高子项的高度**。



