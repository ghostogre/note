## setState的流程

使用`prototype.setState`进行搜索，首先找到`packages\react\src\ReactBaseClasses.js`里的setState：

```ts
Component.prototype.setState = function(partialState, callback) {
  // 校验partialState是否是正确的类型，打印报错。
  debugger; // 添加断点
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```

在Chrome里面打开demo页面（使用script编写简单的渲染，如果想测试函数组件这里换成函数组件即可）。

```html
<script type="text/babel">
      class App extends React.Component {
        constructor (props) {
          super(props);
          this.state = {
            name: 'demo',
            count: 0
          }
        }
        render () {
          const { name, count } = this.state
          return (
            <div>
              <h3>{name}.{count}</h3>
              <button onClick={() => this.setState(preState => ({
                count: preState.count + 1
              }))}>+1</button>
            </div>
          )
        }
      }
      ReactDOM.render(
        <div>
          <App/>
        </div>,
        document.getElementById('container')
      );
</script>
```

如上代码我们编写了一个简单的demo，当我们点击+1按钮的时候会触发setState然后执行到断点。

从debuger开始 step into 执行`this.updater.enqueueSetState`，进入`src/ReactFiberClassComponent.new.js`

在`src/ReactFiberClassComponent.new.js`里定义了一个名为`classComponentUpdater`的对象，上面的enqueueSetState就是在这里做了具体的实现。

```ts
const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime();
    const suspenseConfig = requestCurrentSuspenseConfig();
    const lane = requestUpdateLane(fiber, suspenseConfig);

    const update = createUpdate(eventTime, lane, suspenseConfig);
    update.payload = payload;
    if (callback !== undefined && callback !== null) {
      if (__DEV__) {
        warnOnInvalidCallback(callback, 'setState');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  // ......
 }
```

第一步就是`const fiber = getInstance(inst);`(在浏览器里显示的是`const fiber = get(inst);`，这是因为这个方法是`import {get as getInstance, set as setInstance} from 'shared/ReactInstanceMap';`这样引入的)，我们可以在右侧看到call stack（函数调用栈）和scope（当前作用域里的变量）

我们可以看到 inst 也就是类组件的实例是如下的结构：

![](../images/inst.png)

然后我们进入到get，get的具体定义在`shared/ReactInstanceMap.js`中：

```ts
function get(key) {
    return key._reactInternals;
}
```

这里的key就是inst也就是类组件实例了：

![](../images/key.png)

可以看到返回的是fiberNode的对象。从此我们知道组件对应的fiberNode存在于组件实例的_reactInternals上。

**继续执行**，我们看到定义了一个eventTime，我们使用ctrl + 左键`requestEventTime();`进入到`packages\react-reconciler\src\ReactFiberWorkLoop.new.js`中。

```ts
export function requestEventTime() {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    // 这里NoContext也是一个常量，这里利用二进制常量进行计算，我们可以得知当前调用栈是什么状态
    // 在react中执行，我们能很好的获取到实际时间
    return now();
  }
  // 不在react中，我们可能在浏览器事件执行中
  if (currentEventTime !== NoTimestamp) { // NoTimestamp from './ReactFiberLane'，是常量-1。
    // 直到我们再次进入react，我们给全部的更新使用同一个时间
    return currentEventTime;
  }
  // 第一次更新，计算出开始时间
  currentEventTime = now();
  return currentEventTime;
}
```

暂且知道他是和事件执行时间有关的字段，先不深入，继续往下。