虚拟列表就是只渲染进入用户视野范围的那些DOM，这样可以减少资源内存消耗，实现资源回收。

主要是解决当列表数量较多时，页面内引入大量的 DOM 元素导致页面卡顿的情况，对于列表数量没达到足够的量级（主要根据自己的业务来衡量）但是想提高首屏加载速度时，可以选择按需加载列表，类似于图片的懒加载，并非一次性渲染全部列表，而在滚动到页面底部的时候，再去加载剩余的数据。

但是对于业务需求就是一次性返回所有数据的时候更合适虚拟列表。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。

Mutation Observer 有以下特点：

- 它等待所有脚本任务完成后，才会运行（即异步触发方式）。
- 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。
- 它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。

DOM 每次发生变化，就会生成一条变动记录（`MutationRecord` 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个`MutationRecord`实例所组成的数组。

`MutationRecord`对象包含了DOM的相关信息，有如下属性：

- `type`：观察的变动类型（`attribute`、`characterData`或者`childList`）。
- `target`：发生变动的DOM节点。
- `addedNodes`：新增的DOM节点。
- `removedNodes`：删除的DOM节点。
- `previousSibling`：前一个同级节点，如果没有则返回`null`。
- `nextSibling`：下一个同级节点，如果没有则返回`null`。
- `attributeName`：发生变动的属性。如果设置了`attributeFilter`，则只返回预先指定的属性。
- `oldValue`：变动前的值。这个属性只对`attribute`和`characterData`变动有效，如果发生`childList`变动，则返回`null`。

### 动态高度

如果说高度固定的话，虚拟列表是比较简单的。高度如果不固定的话，会出现高度跳动的情况。

#### 解决方法

1. 添加过渡动效。例如商品详情页，假如商品图不定高，那么就给他一个页面整天的淡入动效（0.3秒不会有特别的视觉影响），缺点是列表会有一定白屏时间。
2. 让运营给定一个近似的预估高度，使得跳动不会太大。例如进入首页的广告弹层，底下有个关闭的图标，可以让运营给定一个弹层的最大高度，然后按照最大高度固定关闭图标，减少视觉上的跳动。

