# 位运算

根据国际 IEEE 754 标准，`JavaScript` 在存储数字时是始终以双精度浮点数来存储的，这种格式用 64 位二进制存储数值，64 位也就是 64 比特（bit），相当于 8 个字节，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号

在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位数值，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以，因为 64 位存储格式是不可见的，但是也正是因为后台这个默认转换操作，给 JS 这门语言产生了一个副作用，即特殊值 NaN 和 Infinity 在位运算中都会直接被当作 0 来处理

**位运算的操作是在数值底层表示上完成的，速度快。**

### 有符号&无符号

在 ECMAScript 中，所有整数字面量默认都是有符号整数

## 按位非 NOT（~）

按位非就是取其二进制的反码，只不过，反码是符号位不变其余位置取反，而按位非则是**取反码后符号位也取反**

>  正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1
>
> 因为计算机中存储负数是以补码的方式来存储的，所以按位非先取反码后符号位取反（我们称这个结果的二进制码为A），如果是负数，该反码A要继续取补码然后补一，然后获取到对应的原码B（A是B的补码）

按位非的最终结果始终是对原数值取反并减一

#### 使用按位非 ~ 判断是否等于-1

```ts
let str = "abcdefg"

if(!~str.indexOf("n")){
	console.log("字符串 str 中不存在字符 n")
}

// 等同于

if(str.indexOf("n") == -1){
  console.log("字符串 str 中不存在字符 n")
}
```

#### 使用按位非 ~ 取整

在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位整数，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以。

这里我们可以看到，32 位 `整数`，位运算操作的是整数，后台在进行 64 位到 32 位转换时，会忽略掉小数部分，只关注整数、整数、整数。

位运算中的双非 `~~` 即可取整，此取整是完全忽略小数部分。

## 按位与（&）

按位与操作符也就是符号 `&` ，它有两个操作数，其实就是将两个操作数的二进制每一位进行对比，两个操作数相应的位都为 1 时，结果为 1，否则都为 0

#### 使用按位与 & 判断奇偶数

按位与这个东西平常用的不太多，我一般只会在判断奇偶数的才会用到，如下：

```js
偶数 & 1 // 0
奇数 & 1 // 1
```

#### 使用按位与 & 判断数字是否为2的整数幂

判断数字是否为 2 的整数幂，使用 `n & (n - 1)`，当结果等于 0 时，数值就是 2 的整数幂

2 的幂在二进制中只有一个 1 后跟一些 0，那么我们在判断一个数字是不是 2 的幂时，用 `n & (n-1)`，如果 你是 2 的幂，n 减 1 之后的二进制就是原来的那一位 1 变成 0，后面的 0 全变成 1，这个时候再和自身做按位与对比时，每一位都不同，所以每一位都是 0，即最终结果为 0

## 按位或（｜）

按位或用符号 `|` 来表示，它也有两个操作数，按位或也是将两个操作数二进制的每一位进行对比，只不过按位或是两边只要有一个 1 ，结果就是 1，只有两边都是 0 ，结果才为 0

#### 使用按位或 ｜ 取整

取整的时候我们也可以使用按位或取整

```js
1.111 | 0 // 1
2.234 | 0 // 2
```

原理也简单，位运算操作的是整数，相当于数值的整数部分和 0 进行按位或运算

0 的二进制全是 0 ，按位或对比时 1 和 0 就是 1 ，0 和 0 就是 0，得出的二进制就是我们要取整数值的整数部分

按位或可以取整，其实四舍五入也就那么回事了，即正数加 0.5，负数减 0.5 进行按位或取整即可。

## 按位异或（^）

按位异或使用字符 `^` 来表示，按位异或和按位或的区别其实就是在比对时，按位异或只在一位是 1 时返回 1，两位都是 1 或者两位都是 0 都返回 0。

#### 使用按位异或 ^ 判断整数部分是否相等

按位异或可以用来判断两个整数是否相等

#### 使用按位异或 ^ 来完成值交换

我们也可以使用按位异或来进行两个变量的值交换

```ts
let a = 1
let b = 2
a ^= b
b ^= a
a ^= b
console.log(a)   // 2
console.log(b)   // 1
```

不过使用 `^` 来做值交换不如用 ES6 的解构，因为 ES6 解构更方便易懂

#### 使用按位异或 ^ 切换 0 和 1

切换 0 和 1，即当变量等于 0 时，将它变成 1，当变量等于 1 时，将它变成 0

#### 使用按位异或 ^ 判断两数符号是否相同

我们可以使用 `(a ^ b) >= 0` 来判断两个数字符号是否相同，也就是说同为正或同为负

## 左移（<<）

#### 简述

左移用符号 `<<` 来表示，正如它的名字，即将数值的二进制码按照指定的位数向左移动，**符号位不变**。左移一位相当于*2。

#### 使用左移 << 取整

使用左移也可取整

```js
1.111 << 0 // 1
2.344 << 0 // 2
```

## 有符号右移（>>）

有符号右移用符号 `>>` 来表示，即将数值的二进制码按照指定的位数向右移动，符号位不变，它和左移相反。

#### 使用右移 >> 取整

使用右移和左移一样都可以取整

## 无符号右移（>>>）

无符号右移使用 `>>>` 表示，和有符号右移区别就是它是三个大于号，它会将数值的所有 32 位字符都右移

对于正数，无符号右移会给空位都补 0 ，不管符号位是什么，这样的话正数的有符号右移和无符号右移结果都是一致的

负数就不一样了，当把一个负数进行无符号右移时也就是说把负数的二进制码包括符号为全部右移，向右被移出的位被丢弃，左侧用0填充，由于符号位变成了 0，所以结果总是非负的。

#### 让十进制 -1 进行无符号右移 0 位

-1 是负数，在内存中二进制存储是补码即 `1111 .... 1111 1111`，32 位都是 1，我们在程序中写入 `-1 >>> 0` 运行得到十进制数字 `4294967295` ，再使用二进制转换工具转为二进制得到的就是 32 位二进制 `1111 .... 1111 1111`，所以就算无符号右移 0 位，得出的依然是一个很大的正数

#### 使用无符号右移 >>> 取整（正数）

无符号右移和有符号右移以及左移都差不多，移 0 位都可取整，只不过无符号右移只能支持正数的取整

