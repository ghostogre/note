> 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。
>
> 元编程是用代码在编译期或运行期生成/改变代码

在 JavaScript 中我们需要 Babel 插件 `babel-plugin-transform-decorators-legacy` 来支持 decorator，在 Typescript 中我们需要在 `tsconfig.json` 里面开启支持选项 `experimentalDecorators`.

两个概念:

1. 目前装饰器本质上是一个函数,`@expression` 的形式其实是一个语法糖, expression 求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入.
2. JavaScript 中的 Class 其实也是一个语法糖

比如在 JavaScript 中我们声明一个 Class:

```ts
class Person{
    say() {
        console.log('hello')
    }
}
```

上面这个 Person 类实际上相当于:

```ts
function Person() {}
Object.defineProperty(Person.prototype, 'say', {
    value: function() { console.log('hello'); },
    enumerable: false,
    configurable: true,
    writable: true
});
```

装饰器是一个函数，它会通过返回一个新函数来修改传入的函数或方法的行为。：

```ts
function addAge(constructor: Function) {
  constructor.prototype.age = 18;
}

@addAge
class Person{
  name: string;
  age!: number;
  constructor() {
    this.name = 'xiaomuzhu';
  }
}

let person = new Person();

/** 等同于 */
Person = addAge(function Person() { ... });
```

当装饰器作为**修饰类**的时候，会把构造器传递进去。

在**属性/方法**的装饰器定义过程中,与 class 的装饰器不同, 装饰器函数中的参数变为了三个 `target`、`propertyKey`、`descriptor`.这三个参数正是源于`Object.defineProperty`,也就是上面提到的 Class 本质是语法糖，实际上属性/方法装饰器是借助`Object.defineProperty`修改类的方法和属性.

访问器属性getter或者setter同样可以用属性装饰器修饰。

