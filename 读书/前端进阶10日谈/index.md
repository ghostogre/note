1. 元素的**class属性**可以用来定义元素的某种业务状态或者业务模式，然后通过CSS的类选择器根据业务需求将元素设置成对应的样式，从而避免了将这些本该由CSS完成的任务交由JS完成。（使用类名切换样式可读性更佳，一些简单的图形或者文字可以用伪元素）不过需要注意的是完全使用CSS去做，可读性可能就会很差，比如用label + checkbox实现完全使用css切换样式。

2. 修改ul列表的样式（前面的点），可以使用 list-style 指定图片链接 - `list-style: url()`。但是这样消耗网络请求并且不能很好的设置大小。可以改用伪元素和 **border** 实现列表前面的小三角形。CSS的 border 能够实现的图案还有很多，比如可以使用上下两个三角形重叠实现六芒星团。

- 在一个项目里，通常HTML结构保持越简单，项目的JS代码也会相应简洁，代码的可维护性就会大大增强。所以，**保持HTML结构简单**，尽量不增加冗余标签，是每个前端工程师必须要思考并努力去做到的。

- 纯CSS饼图：可以使用border实现（使用border的好处就是可以很好的设置左右异色的图案，不用增加元素，但是问题是使用border一般就没有空间加入内容了，所以可以用线性渐变背景代替），使用border实现一个异色的圆，然后伪元素实现一个一半透明的圆，旋转伪元素就可以实现百分比饼图了，但是需要在旋转超过180度的时候更换伪元素的颜色。

  **技巧**：饼图中，百分比不是写死的话，需要使用内联操作伪元素的样式（当然也可以用伪元素当背景，操作的就不是伪元素了，直接修改背景渐变轴），但是伪元素是不可以被内联样式操作的，但是伪元素会继承animation属性，所以我们可以通过`animation-delay`属性的内联样式来控制它们。

- **CSS自定义属性**：`--*`来声明变量名，在需要用到的地方使用 `var(--*)`方式动态地引入这些值，这个方式现在在除了IE之外的浏览器上基本上运行良好。

3. **封装性**：函数体内部不应该有完全来自外部环境的变量，除非这个函数不打算复用（可以改为参数传入）

- **数据抽象就是把数据定义并聚合成能被过程处理的对象，交由特定的过程处理。**简单来说就是数据的结构化，将数据结构化传入函数进行解析然后处理。数据抽象的代码可以适应不同状态和时间的业务需求，我们只需要修改数据抽象即可。

- 改变外部状态的部分叫做代码的**副作用(side-effect)**。我们可以考虑**把函数体内部有副作用的代码剥离出来**，这往往能提升函数的通用性、稳定性和可测试性。（例如我们可以把副作用提取出，作为一个函数）

  > 没有this的情况下或者不需要this的情况下，使用bind，我们可以类似`updateState.bind(null, i + 1)`绑定一个null。

4. **可读性**：使用`async/await`能够把异步的递归简化为更容易让人阅读和理解的循环，用 promise 包裹 timeout 然后使用`async/await`。

5. **正确性**：比方说，需要获得一个随机数，需要保证取随机数时候的公平性。

   > splice 的复杂度是 o(n2) ，可以用其他方法代替的情况下，不使用可以达到优化效果。

6. **过程抽象**

   - **只执行一次**：点击移除一个DOM的时候，如果连续快速的点击可能会出现报错，因为DOM已经移除了，所以我们需要保证点击只执行一次。
     1. 可以通过`addEventListener`的`once`参数实现
     2. 在click事件处理函数中，通过`target.removeEventListener('click', f);`将处理函数本身从事件监听中移除。
     3. 也可以使用元素的`disabled`属性来实现目标元素只被点击一次的效果
   - 把“只执行一次“这个需求从事件处理函数中剥离出来。这个过程我们称为**过程抽象**。将“只执行一次”的过程抽象出来后，不论是我们的事件处理函数还是表单提交函数都只需要关注业务逻辑。（只执行一次这个需求可以用闭包实现，类似防抖节流）
   - `once`、`debounce`、`throttle`这些函数装饰器有一个共同点：它们的参数是函数，返回值也是函数。我们把这种参数和返回值都是函数的函数，叫做**高阶函数**。

7. **函数拦截器**：假设一个工具库要废弃一些API，肯定不能直接废弃，而是调用前给用户一个警告提示`console.warn`。但是我们不可能说直接在API代码里加入错误打印，如何可以不改动原来库中API，又可以在这些废弃的API调用前显示提示信息呢？我们**可以用一个高阶函数修饰原本的API，然后返回修饰后的高阶函数**。

8. 一个严格的纯函数，是具有**确定性**、**无副作用**，**幂等**的特点。也就是说，纯函数不依赖外部环境，也不改变外部环境，不管调用几次，不管什么时候调用，只要参数确定，返回值就确定。这样的函数，就是纯函数。纯函数提升了代码的可测试性和可维护性。

9. **高阶函数的范式**：

   ```ts
   function HOF0(fn) {
     return function(...args) {
       return fn.apply(this, args);
     }
   }
   ```

   

